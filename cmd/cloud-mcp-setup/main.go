package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
)

const (
	directoryPerms = 0o755
	filePerms      = 0o600

	wrapperScript = `#!/bin/bash
set -euo pipefail

# CloudMCP Wrapper Script - Auto-generated by cloud-mcp-setup
# This script starts the CloudMCP server with TOML configuration

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Helper functions
error() {
	echo -e "${RED}Error:${NC} $1" >&2
}

warning() {
	echo -e "${YELLOW}Warning:${NC} $1" >&2
}

info() {
	echo -e "${GREEN}Info:${NC} $1" >&2
}

# Check if cloud-mcp binary is available
if ! command -v cloud-mcp &>/dev/null; then
	error "cloud-mcp binary not found in PATH"
	info "Please ensure cloud-mcp is installed via 'go install github.com/chadit/CloudMCP/cmd/server@latest'"
	exit 1
fi

# CloudMCP automatically detects TOML configuration
# First run will create default config with placeholder tokens
# Use the MCP account management commands to add your tokens:
#   cloudmcp_account_list
#   cloudmcp_account_add --name primary --token your_token --label "Primary Account"

# Start the CloudMCP server
exec cloud-mcp "$@"
`

	tomlConfigTemplate = `[system]
server_name = "Cloud MCP Server"
log_level = "info"
enable_metrics = true
metrics_port = 8080
default_account = "primary"

# Logging configuration
log_max_size = 10      # MB
log_max_backups = 5    # Number of files to keep
log_max_age = 30       # Days to retain logs

[account.primary]
token = "your_linode_token_here"
label = "Primary Account"

# Example additional account:
# [account.development]
# token = "your_dev_token_here"
# label = "Development"
# apiurl = "https://api.dev.linode.com/v4"  # Optional custom API URL
`
)

var (
	showHelp   bool
	forceSetup bool
	uninstall  bool
	localMode  bool
	localPath  string
)

func init() {
	flag.BoolVar(&showHelp, "help", false, "Show help message")
	flag.BoolVar(&showHelp, "h", false, "Show help message (shorthand)")
	flag.BoolVar(&forceSetup, "force", false, "Force setup even if already configured")
	flag.BoolVar(&uninstall, "uninstall", false, "Remove CloudMCP configuration")
	flag.BoolVar(&localMode, "local", false, "Setup for local development (use project directory)")
	flag.StringVar(&localPath, "path", "", "Path to CloudMCP project directory (for local mode)")
}

func main() {
	flag.Parse()

	if showHelp {
		printHelp()
		return
	}

	if uninstall {
		doUninstall()
		return
	}

	doSetup(localMode, localPath)
}

func printHelp() {
	fmt.Println("CloudMCP Setup Tool")
	fmt.Println("==================")
	fmt.Println()
	fmt.Println("This tool sets up CloudMCP for use with Claude Desktop and Claude Code.")
	fmt.Println()
	fmt.Println("Usage:")
	fmt.Println("  cloud-mcp-setup              # Setup for go install (uses ~/.cloud-mcp)")
	fmt.Println("  cloud-mcp-setup -local       # Setup for local development")
	fmt.Println("  cloud-mcp-setup -local -path /path/to/cloudmcp  # Specify project path")
	fmt.Println("  cloud-mcp-setup -force       # Force setup even if already configured")
	fmt.Println("  cloud-mcp-setup -uninstall   # Remove CloudMCP configuration")
	fmt.Println()
	fmt.Println("The setup will:")
	fmt.Println("  1. Configure wrapper script for MCP integration")
	fmt.Println("  2. Register CloudMCP with Claude Desktop and Claude Code")
	fmt.Println("  3. Create default TOML configuration template")
	fmt.Println()
	fmt.Println("For go install mode: Configuration is stored using XDG directories")
	fmt.Println("For local mode: Uses the project directory and its cloud-mcp-wrapper.sh")
}

func doSetup(localMode bool, localPath string) {
	fmt.Println("CloudMCP Setup")
	fmt.Println("==============")
	fmt.Println()

	homeDir, err := os.UserHomeDir()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: Cannot determine home directory: %v\n", err)
		os.Exit(1)
	}

	var wrapperPath, configPath string
	var cloudMCPDir string

	if localMode {
		// Local development mode
		if localPath == "" {
			// Try to find the project directory
			cwd, _ := os.Getwd()
			if _, err := os.Stat(filepath.Join(cwd, "cloud-mcp-wrapper.sh")); err == nil {
				localPath = cwd
			} else if _, err := os.Stat(filepath.Join(cwd, "..", "cloud-mcp-wrapper.sh")); err == nil {
				localPath = filepath.Join(cwd, "..")
			} else {
				fmt.Fprintf(os.Stderr, "Error: Cannot find CloudMCP project directory. Use --path flag.\n")
				os.Exit(1)
			}
		}

		// Verify project directory
		wrapperPath = filepath.Join(localPath, "cloud-mcp-wrapper.sh")
		if _, err := os.Stat(wrapperPath); os.IsNotExist(err) {
			fmt.Fprintf(os.Stderr, "Error: cloud-mcp-wrapper.sh not found in %s\n", localPath)
			os.Exit(1)
		}

		// For local mode, suggest using TOML config but don't force it
		cloudMCPDir = localPath

		fmt.Printf("Using local project at: %s\n", localPath)
	} else {
		// Go install mode - use ~/.cloud-mcp
		cloudMCPDir = filepath.Join(homeDir, ".cloud-mcp")
		if err := os.MkdirAll(cloudMCPDir, directoryPerms); err != nil {
			fmt.Fprintf(os.Stderr, "Error: Cannot create directory %s: %v\n", cloudMCPDir, err)
			os.Exit(1)
		}

		// Create wrapper script
		wrapperPath = filepath.Join(cloudMCPDir, "cloud-mcp-wrapper.sh")
		if _, err := os.Stat(wrapperPath); err == nil && !forceSetup {
			fmt.Printf("✓ Wrapper script already exists at %s\n", wrapperPath)
		} else {
			if err := os.WriteFile(wrapperPath, []byte(wrapperScript), 0o755); err != nil {
				fmt.Fprintf(os.Stderr, "Error: Cannot create wrapper script: %v\n", err)
				os.Exit(1)
			}
			fmt.Printf("✓ Created wrapper script at %s\n", wrapperPath)
		}

	}

	// Handle TOML configuration
	if !localMode {
		// For go install mode, create a basic TOML config template
		configPath = filepath.Join(cloudMCPDir, "config-template.toml")
		if _, err := os.Stat(configPath); os.IsNotExist(err) {
			if err := os.WriteFile(configPath, []byte(tomlConfigTemplate), 0o644); err != nil {
				fmt.Fprintf(os.Stderr, "Warning: Cannot create config template: %v\n", err)
			} else {
				fmt.Printf("✓ Created TOML configuration template at %s\n", configPath)
			}
		} else {
			fmt.Printf("✓ Configuration template already exists at %s\n", configPath)
		}
	}

	// Setup Claude Code
	setupClaudeCode(wrapperPath)

	// Setup Claude Desktop
	setupClaudeDesktop(wrapperPath)

	// Setup VS Code
	setupVSCode(wrapperPath)

	fmt.Println()
	fmt.Println("Setup complete! Next steps:")
	if localMode {
		fmt.Println("1. Start CloudMCP server (it will create default TOML configuration)")
		fmt.Println("2. Use MCP account management commands to add your Linode API tokens:")
		fmt.Println("   - cloudmcp_account_list")
		fmt.Println("   - cloudmcp_account_add --name primary --token YOUR_TOKEN --label \"Primary\"")
	} else {
		fmt.Println("1. Start CloudMCP server (it will create default TOML configuration)")
		fmt.Println("2. Use MCP account management commands to add your Linode API tokens:")
		fmt.Println("   - cloudmcp_account_list")
		fmt.Println("   - cloudmcp_account_add --name primary --token YOUR_TOKEN --label \"Primary\"")
		if configPath != "" {
			fmt.Printf("3. Optional: Reference config template at %s\n", configPath)
			fmt.Println("4. Restart Claude Desktop, Claude Code, and/or VS Code")
			fmt.Println("5. CloudMCP should appear in your MCP server list")
		} else {
			fmt.Println("3. Restart Claude Desktop, Claude Code, and/or VS Code")
			fmt.Println("4. CloudMCP should appear in your MCP server list")
		}
		return
	}
	fmt.Println("3. Restart Claude Desktop, Claude Code, and/or VS Code")
	fmt.Println("4. CloudMCP should appear in your MCP server list")
}

func setupClaudeCode(wrapperPath string) {
	fmt.Println()
	fmt.Println("Setting up Claude Code...")

	// Check if claude CLI is available
	if _, err := exec.LookPath("claude"); err != nil {
		fmt.Println("⚠️  Claude Code CLI not found")
		fmt.Println("   Install from: https://claude.ai/code")
		return
	}

	// Check if already configured
	homeDir, _ := os.UserHomeDir()
	claudeConfigPath := filepath.Join(homeDir, ".claude.json")

	if data, err := os.ReadFile(claudeConfigPath); err == nil {
		if strings.Contains(string(data), "cloud-mcp") && !forceSetup {
			fmt.Println("✓ CloudMCP already configured in Claude Code")
			return
		}
	}

	// Add using claude CLI
	cmd := exec.Command("claude", "mcp", "add", "-s", "user", "cloud-mcp", wrapperPath)
	if output, err := cmd.CombinedOutput(); err != nil {
		fmt.Printf("⚠️  Failed to add CloudMCP to Claude Code: %v\n", err)
		if len(output) > 0 {
			fmt.Printf("   Output: %s\n", string(output))
		}
	} else {
		fmt.Println("✓ CloudMCP added to Claude Code")
	}
}

func setupClaudeDesktop(wrapperPath string) {
	fmt.Println()
	fmt.Println("Setting up Claude Desktop...")

	if runtime.GOOS != "darwin" {
		fmt.Println("⚠️  Claude Desktop setup is only supported on macOS")
		return
	}

	homeDir, _ := os.UserHomeDir()
	configPath := filepath.Join(homeDir, "Library", "Application Support", "Claude", "claude_desktop_config.json")

	// Check if config exists
	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		fmt.Println("⚠️  Claude Desktop configuration not found")
		fmt.Println("   Please run Claude Desktop at least once")
		return
	}

	// Read existing config
	data, err := os.ReadFile(configPath)
	if err != nil {
		fmt.Printf("⚠️  Cannot read Claude Desktop config: %v\n", err)
		return
	}

	// Check if already configured
	if strings.Contains(string(data), "cloud-mcp") && !forceSetup {
		fmt.Println("✓ CloudMCP already configured in Claude Desktop")
		return
	}

	// Parse config
	var config map[string]interface{}
	if err := json.Unmarshal(data, &config); err != nil {
		fmt.Printf("⚠️  Cannot parse Claude Desktop config: %v\n", err)
		return
	}

	// Add CloudMCP
	if servers, ok := config["mcpServers"].(map[string]interface{}); ok {
		servers["cloud-mcp"] = map[string]interface{}{
			"command": wrapperPath,
			"args":    []string{},
			"env":     map[string]string{},
		}
	} else {
		config["mcpServers"] = map[string]interface{}{
			"cloud-mcp": map[string]interface{}{
				"command": wrapperPath,
				"args":    []string{},
				"env":     map[string]string{},
			},
		}
	}

	// Write back
	newData, err := json.MarshalIndent(config, "", "  ")
	if err != nil {
		fmt.Printf("⚠️  Cannot marshal config: %v\n", err)
		return
	}

	// Backup original
	backupPath := configPath + ".bak"
	if err := os.WriteFile(backupPath, data, 0o644); err != nil {
		fmt.Printf("⚠️  Cannot create backup: %v\n", err)
		return
	}

	// Write new config
	if err := os.WriteFile(configPath, newData, 0o644); err != nil {
		fmt.Printf("⚠️  Cannot write config: %v\n", err)
		return
	}

	fmt.Println("✓ CloudMCP added to Claude Desktop")
}

func setupVSCode(wrapperPath string) {
	fmt.Println()
	fmt.Println("Setting up VS Code...")

	// Check for VS Code settings
	homeDir, _ := os.UserHomeDir()

	// VS Code settings locations (in order of preference)
	settingsPaths := []string{
		filepath.Join(homeDir, ".config", "Code", "User", "settings.json"),                        // Linux
		filepath.Join(homeDir, "Library", "Application Support", "Code", "User", "settings.json"), // macOS
		filepath.Join(homeDir, "AppData", "Roaming", "Code", "User", "settings.json"),             // Windows
	}

	var settingsPath string
	for _, path := range settingsPaths {
		if _, err := os.Stat(path); err == nil {
			settingsPath = path
			break
		}
	}

	if settingsPath == "" {
		fmt.Println("⚠️  VS Code settings not found")
		fmt.Println("   Please add the following to your VS Code settings.json:")
		fmt.Println()
		fmt.Println("   \"github.copilot.chat.mcpServers\": {")
		fmt.Printf("     \"cloud-mcp\": {\n")
		fmt.Printf("       \"command\": \"%s\",\n", wrapperPath)
		fmt.Println("       \"args\": []")
		fmt.Println("     }")
		fmt.Println("   }")
		return
	}

	// Read existing settings
	data, err := os.ReadFile(settingsPath)
	if err != nil {
		fmt.Printf("⚠️  Cannot read VS Code settings: %v\n", err)
		return
	}

	// Check if already configured
	if strings.Contains(string(data), "cloud-mcp") && !forceSetup {
		fmt.Println("✓ CloudMCP already configured in VS Code")
		return
	}

	// Parse settings (VS Code allows comments, so we need to handle them)
	// For simplicity, we'll do a string-based approach
	settingsStr := string(data)

	// Check if github.copilot.chat.mcpServers exists
	if strings.Contains(settingsStr, "github.copilot.chat.mcpServers") {
		// Add to existing mcpServers
		fmt.Println("⚠️  github.copilot.chat.mcpServers already exists in settings")
		fmt.Println("   Please manually add cloud-mcp to the existing configuration:")
		fmt.Println()
		fmt.Printf("     \"cloud-mcp\": {\n")
		fmt.Printf("       \"command\": \"%s\",\n", wrapperPath)
		fmt.Println("       \"args\": []")
		fmt.Println("     }")
	} else {
		// Create backup
		backupPath := settingsPath + ".bak"
		if err := os.WriteFile(backupPath, data, 0o644); err != nil {
			fmt.Printf("⚠️  Cannot create backup: %v\n", err)
			return
		}

		// Find the last closing brace
		lastBrace := strings.LastIndex(settingsStr, "}")
		if lastBrace == -1 {
			fmt.Println("⚠️  Invalid VS Code settings format")
			return
		}

		// Insert the new configuration
		newConfig := fmt.Sprintf(`  "github.copilot.chat.mcpServers": {
    "cloud-mcp": {
      "command": "%s",
      "args": []
    }
  }`, wrapperPath)

		// Check if we need a comma before our new config
		trimmed := strings.TrimSpace(settingsStr[:lastBrace])
		needsComma := len(trimmed) > 0 && trimmed[len(trimmed)-1] != '{'

		if needsComma {
			newConfig = ",\n" + newConfig
		}

		// Build the new settings
		newSettings := settingsStr[:lastBrace] + newConfig + "\n" + settingsStr[lastBrace:]

		// Write the new settings
		if err := os.WriteFile(settingsPath, []byte(newSettings), 0o644); err != nil {
			fmt.Printf("⚠️  Cannot write VS Code settings: %v\n", err)
			// Restore backup
			os.Rename(backupPath, settingsPath)
			return
		}

		fmt.Println("✓ CloudMCP added to VS Code settings")
	}
}

func doUninstall() {
	fmt.Println("CloudMCP Uninstall")
	fmt.Println("==================")
	fmt.Println()

	homeDir, _ := os.UserHomeDir()

	// Remove from Claude Code
	if _, err := exec.LookPath("claude"); err == nil {
		fmt.Println("Removing from Claude Code...")
		cmd := exec.Command("claude", "mcp", "remove", "-s", "user", "cloud-mcp")
		if output, err := cmd.CombinedOutput(); err != nil {
			fmt.Printf("⚠️  Failed to remove from Claude Code: %v\n", err)
			if len(output) > 0 {
				fmt.Printf("   Output: %s\n", string(output))
			}
		} else {
			fmt.Println("✓ Removed from Claude Code")
		}
	}

	// Remove from Claude Desktop
	if runtime.GOOS == "darwin" {
		configPath := filepath.Join(homeDir, "Library", "Application Support", "Claude", "claude_desktop_config.json")
		if data, err := os.ReadFile(configPath); err == nil {
			var config map[string]interface{}
			if err := json.Unmarshal(data, &config); err == nil {
				if servers, ok := config["mcpServers"].(map[string]interface{}); ok {
					delete(servers, "cloud-mcp")
					if newData, err := json.MarshalIndent(config, "", "  "); err == nil {
						if err := os.WriteFile(configPath, newData, 0o644); err == nil {
							fmt.Println("✓ Removed from Claude Desktop")
						}
					}
				}
			}
		}
	}

	// Remove from VS Code
	fmt.Println()
	fmt.Println("Removing from VS Code...")
	settingsPaths := []string{
		filepath.Join(homeDir, ".config", "Code", "User", "settings.json"),
		filepath.Join(homeDir, "Library", "Application Support", "Code", "User", "settings.json"),
		filepath.Join(homeDir, "AppData", "Roaming", "Code", "User", "settings.json"),
	}

	for _, settingsPath := range settingsPaths {
		if data, err := os.ReadFile(settingsPath); err == nil {
			if strings.Contains(string(data), "cloud-mcp") {
				fmt.Printf("⚠️  Please manually remove cloud-mcp from VS Code settings: %s\n", settingsPath)
				break
			}
		}
	}

	// Optionally remove ~/.cloud-mcp directory
	cloudMCPDir := filepath.Join(homeDir, ".cloud-mcp")
	fmt.Println()
	fmt.Printf("The configuration directory %s still exists.\n", cloudMCPDir)
	fmt.Println("You can manually remove it if you no longer need it.")
}
