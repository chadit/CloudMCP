package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
)

const (
	wrapperScript = `#!/bin/bash
set -euo pipefail

# CloudMCP Wrapper Script - Auto-generated by cloud-mcp-setup
# This script loads environment variables and starts the CloudMCP server

# Default paths
ENV_FILE="${HOME}/.cloud-mcp/.env"

# Check if .env file exists
if [[ ! -f "$ENV_FILE" ]]; then
	echo "Error: Configuration file not found: $ENV_FILE" >&2
	echo "Please create it with your Linode API tokens" >&2
	echo "" >&2
	echo "Example:" >&2
	echo "  DEFAULT_LINODE_ACCOUNT=primary" >&2
	echo "  LINODE_ACCOUNTS_PRIMARY_TOKEN=your_token_here" >&2
	echo "  LINODE_ACCOUNTS_PRIMARY_LABEL=\"Production\"" >&2
	exit 1
fi

# Load environment variables from .env file
set -a
source "$ENV_FILE"
set +a

# Start the CloudMCP server
exec cloud-mcp "$@"
`

	envExample = `# CloudMCP Configuration
# This file should be placed at ~/.cloud-mcp/.env

# Core Configuration
CLOUD_MCP_SERVER_NAME="Cloud MCP Server"
LOG_LEVEL=info
ENABLE_METRICS=true
METRICS_PORT=8080

# Linode Accounts
DEFAULT_LINODE_ACCOUNT=primary

# Primary Account
LINODE_ACCOUNTS_PRIMARY_TOKEN=your_production_token_here
LINODE_ACCOUNTS_PRIMARY_LABEL="Production"

# Development Account (optional)
# LINODE_ACCOUNTS_DEV_TOKEN=your_dev_token_here
# LINODE_ACCOUNTS_DEV_LABEL="Development"
`
)

var (
	showHelp    bool
	forceSetup  bool
	uninstall   bool
	localMode   bool
	localPath   string
)

func init() {
	flag.BoolVar(&showHelp, "help", false, "Show help message")
	flag.BoolVar(&showHelp, "h", false, "Show help message (shorthand)")
	flag.BoolVar(&forceSetup, "force", false, "Force setup even if already configured")
	flag.BoolVar(&uninstall, "uninstall", false, "Remove CloudMCP configuration")
	flag.BoolVar(&localMode, "local", false, "Setup for local development (use project directory)")
	flag.StringVar(&localPath, "path", "", "Path to CloudMCP project directory (for local mode)")
}

func main() {
	flag.Parse()

	if showHelp {
		printHelp()
		return
	}

	if uninstall {
		doUninstall()
		return
	}

	doSetup(localMode, localPath)
}

func printHelp() {
	fmt.Println("CloudMCP Setup Tool")
	fmt.Println("==================")
	fmt.Println()
	fmt.Println("This tool sets up CloudMCP for use with Claude Desktop and Claude Code.")
	fmt.Println()
	fmt.Println("Usage:")
	fmt.Println("  cloud-mcp-setup              # Setup for go install (uses ~/.cloud-mcp)")
	fmt.Println("  cloud-mcp-setup -local       # Setup for local development")
	fmt.Println("  cloud-mcp-setup -local -path /path/to/cloudmcp  # Specify project path")
	fmt.Println("  cloud-mcp-setup -force       # Force setup even if already configured")
	fmt.Println("  cloud-mcp-setup -uninstall   # Remove CloudMCP configuration")
	fmt.Println()
	fmt.Println("The setup will:")
	fmt.Println("  1. Configure environment and wrapper script")
	fmt.Println("  2. Register CloudMCP with Claude Desktop and Claude Code")
	fmt.Println("  3. Create an example .env file for your API tokens")
	fmt.Println()
	fmt.Println("For go install mode: Configuration is stored in ~/.cloud-mcp/")
	fmt.Println("For local mode: Uses the project directory and its cloud-mcp-wrapper.sh")
}

func doSetup(localMode bool, localPath string) {
	fmt.Println("CloudMCP Setup")
	fmt.Println("==============")
	fmt.Println()

	homeDir, err := os.UserHomeDir()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: Cannot determine home directory: %v\n", err)
		os.Exit(1)
	}

	var wrapperPath, envPath, envExamplePath string
	var cloudMCPDir string

	if localMode {
		// Local development mode
		if localPath == "" {
			// Try to find the project directory
			cwd, _ := os.Getwd()
			if _, err := os.Stat(filepath.Join(cwd, "cloud-mcp-wrapper.sh")); err == nil {
				localPath = cwd
			} else if _, err := os.Stat(filepath.Join(cwd, "..", "cloud-mcp-wrapper.sh")); err == nil {
				localPath = filepath.Join(cwd, "..")
			} else {
				fmt.Fprintf(os.Stderr, "Error: Cannot find CloudMCP project directory. Use --path flag.\n")
				os.Exit(1)
			}
		}
		
		// Verify project directory
		wrapperPath = filepath.Join(localPath, "cloud-mcp-wrapper.sh")
		if _, err := os.Stat(wrapperPath); os.IsNotExist(err) {
			fmt.Fprintf(os.Stderr, "Error: cloud-mcp-wrapper.sh not found in %s\n", localPath)
			os.Exit(1)
		}
		
		envPath = filepath.Join(localPath, ".env")
		envExamplePath = filepath.Join(localPath, ".env.example")
		cloudMCPDir = localPath
		
		fmt.Printf("Using local project at: %s\n", localPath)
	} else {
		// Go install mode - use ~/.cloud-mcp
		cloudMCPDir = filepath.Join(homeDir, ".cloud-mcp")
		if err := os.MkdirAll(cloudMCPDir, 0755); err != nil {
			fmt.Fprintf(os.Stderr, "Error: Cannot create directory %s: %v\n", cloudMCPDir, err)
			os.Exit(1)
		}

		// Create wrapper script
		wrapperPath = filepath.Join(cloudMCPDir, "cloud-mcp-wrapper.sh")
		if _, err := os.Stat(wrapperPath); err == nil && !forceSetup {
			fmt.Printf("✓ Wrapper script already exists at %s\n", wrapperPath)
		} else {
			if err := os.WriteFile(wrapperPath, []byte(wrapperScript), 0755); err != nil {
				fmt.Fprintf(os.Stderr, "Error: Cannot create wrapper script: %v\n", err)
				os.Exit(1)
			}
			fmt.Printf("✓ Created wrapper script at %s\n", wrapperPath)
		}
		
		envPath = filepath.Join(cloudMCPDir, ".env")
		envExamplePath = filepath.Join(cloudMCPDir, ".env.example")
	}

	// Handle .env file
	
	if _, err := os.Stat(envPath); os.IsNotExist(err) {
		// Check if .env.example exists to copy from
		if _, err := os.Stat(envExamplePath); err == nil {
			// Copy from .env.example
			exampleData, _ := os.ReadFile(envExamplePath)
			if err := os.WriteFile(envPath, exampleData, 0600); err != nil {
				fmt.Fprintf(os.Stderr, "Error: Cannot create .env file: %v\n", err)
				os.Exit(1)
			}
		} else {
			// Use embedded template
			if err := os.WriteFile(envPath, []byte(envExample), 0600); err != nil {
				fmt.Fprintf(os.Stderr, "Error: Cannot create .env file: %v\n", err)
				os.Exit(1)
			}
		}
		fmt.Printf("✓ Created configuration template at %s\n", envPath)
		fmt.Println()
		if localMode {
			fmt.Printf("⚠️  IMPORTANT: Edit %s with your Linode API tokens\n", envPath)
		} else {
			fmt.Println("⚠️  IMPORTANT: Edit ~/.cloud-mcp/.env with your Linode API tokens")
		}
	} else {
		fmt.Printf("✓ Configuration file already exists at %s\n", envPath)
	}

	// Always create/update .env.example (only for go install mode)
	if !localMode {
		if err := os.WriteFile(envExamplePath, []byte(envExample), 0644); err != nil {
			fmt.Fprintf(os.Stderr, "Warning: Cannot create .env.example: %v\n", err)
		}
	}

	// Setup Claude Code
	setupClaudeCode(wrapperPath)

	// Setup Claude Desktop
	setupClaudeDesktop(wrapperPath)

	// Setup VS Code
	setupVSCode(wrapperPath)

	fmt.Println()
	fmt.Println("Setup complete! Next steps:")
	if localMode {
		fmt.Printf("1. Edit %s with your Linode API tokens\n", envPath)
	} else {
		fmt.Println("1. Edit ~/.cloud-mcp/.env with your Linode API tokens")
	}
	fmt.Println("2. Restart Claude Desktop, Claude Code, and/or VS Code")
	fmt.Println("3. CloudMCP should appear in your MCP server list")
}

func setupClaudeCode(wrapperPath string) {
	fmt.Println()
	fmt.Println("Setting up Claude Code...")

	// Check if claude CLI is available
	if _, err := exec.LookPath("claude"); err != nil {
		fmt.Println("⚠️  Claude Code CLI not found")
		fmt.Println("   Install from: https://claude.ai/code")
		return
	}

	// Check if already configured
	homeDir, _ := os.UserHomeDir()
	claudeConfigPath := filepath.Join(homeDir, ".claude.json")
	
	if data, err := os.ReadFile(claudeConfigPath); err == nil {
		if strings.Contains(string(data), "cloud-mcp") && !forceSetup {
			fmt.Println("✓ CloudMCP already configured in Claude Code")
			return
		}
	}

	// Add using claude CLI
	cmd := exec.Command("claude", "mcp", "add", "-s", "user", "cloud-mcp", wrapperPath)
	if output, err := cmd.CombinedOutput(); err != nil {
		fmt.Printf("⚠️  Failed to add CloudMCP to Claude Code: %v\n", err)
		if len(output) > 0 {
			fmt.Printf("   Output: %s\n", string(output))
		}
	} else {
		fmt.Println("✓ CloudMCP added to Claude Code")
	}
}

func setupClaudeDesktop(wrapperPath string) {
	fmt.Println()
	fmt.Println("Setting up Claude Desktop...")

	if runtime.GOOS != "darwin" {
		fmt.Println("⚠️  Claude Desktop setup is only supported on macOS")
		return
	}

	homeDir, _ := os.UserHomeDir()
	configPath := filepath.Join(homeDir, "Library", "Application Support", "Claude", "claude_desktop_config.json")

	// Check if config exists
	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		fmt.Println("⚠️  Claude Desktop configuration not found")
		fmt.Println("   Please run Claude Desktop at least once")
		return
	}

	// Read existing config
	data, err := os.ReadFile(configPath)
	if err != nil {
		fmt.Printf("⚠️  Cannot read Claude Desktop config: %v\n", err)
		return
	}

	// Check if already configured
	if strings.Contains(string(data), "cloud-mcp") && !forceSetup {
		fmt.Println("✓ CloudMCP already configured in Claude Desktop")
		return
	}

	// Parse config
	var config map[string]interface{}
	if err := json.Unmarshal(data, &config); err != nil {
		fmt.Printf("⚠️  Cannot parse Claude Desktop config: %v\n", err)
		return
	}

	// Add CloudMCP
	if servers, ok := config["mcpServers"].(map[string]interface{}); ok {
		servers["cloud-mcp"] = map[string]interface{}{
			"command": wrapperPath,
			"args":    []string{},
			"env":     map[string]string{},
		}
	} else {
		config["mcpServers"] = map[string]interface{}{
			"cloud-mcp": map[string]interface{}{
				"command": wrapperPath,
				"args":    []string{},
				"env":     map[string]string{},
			},
		}
	}

	// Write back
	newData, err := json.MarshalIndent(config, "", "  ")
	if err != nil {
		fmt.Printf("⚠️  Cannot marshal config: %v\n", err)
		return
	}

	// Backup original
	backupPath := configPath + ".bak"
	if err := os.WriteFile(backupPath, data, 0644); err != nil {
		fmt.Printf("⚠️  Cannot create backup: %v\n", err)
		return
	}

	// Write new config
	if err := os.WriteFile(configPath, newData, 0644); err != nil {
		fmt.Printf("⚠️  Cannot write config: %v\n", err)
		return
	}

	fmt.Println("✓ CloudMCP added to Claude Desktop")
}

func setupVSCode(wrapperPath string) {
	fmt.Println()
	fmt.Println("Setting up VS Code...")

	// Check for VS Code settings
	homeDir, _ := os.UserHomeDir()
	
	// VS Code settings locations (in order of preference)
	settingsPaths := []string{
		filepath.Join(homeDir, ".config", "Code", "User", "settings.json"),           // Linux
		filepath.Join(homeDir, "Library", "Application Support", "Code", "User", "settings.json"), // macOS
		filepath.Join(homeDir, "AppData", "Roaming", "Code", "User", "settings.json"), // Windows
	}

	var settingsPath string
	for _, path := range settingsPaths {
		if _, err := os.Stat(path); err == nil {
			settingsPath = path
			break
		}
	}

	if settingsPath == "" {
		fmt.Println("⚠️  VS Code settings not found")
		fmt.Println("   Please add the following to your VS Code settings.json:")
		fmt.Println()
		fmt.Println("   \"github.copilot.chat.mcpServers\": {")
		fmt.Printf("     \"cloud-mcp\": {\n")
		fmt.Printf("       \"command\": \"%s\",\n", wrapperPath)
		fmt.Println("       \"args\": []")
		fmt.Println("     }")
		fmt.Println("   }")
		return
	}

	// Read existing settings
	data, err := os.ReadFile(settingsPath)
	if err != nil {
		fmt.Printf("⚠️  Cannot read VS Code settings: %v\n", err)
		return
	}

	// Check if already configured
	if strings.Contains(string(data), "cloud-mcp") && !forceSetup {
		fmt.Println("✓ CloudMCP already configured in VS Code")
		return
	}

	// Parse settings (VS Code allows comments, so we need to handle them)
	// For simplicity, we'll do a string-based approach
	settingsStr := string(data)
	
	// Check if github.copilot.chat.mcpServers exists
	if strings.Contains(settingsStr, "github.copilot.chat.mcpServers") {
		// Add to existing mcpServers
		fmt.Println("⚠️  github.copilot.chat.mcpServers already exists in settings")
		fmt.Println("   Please manually add cloud-mcp to the existing configuration:")
		fmt.Println()
		fmt.Printf("     \"cloud-mcp\": {\n")
		fmt.Printf("       \"command\": \"%s\",\n", wrapperPath)
		fmt.Println("       \"args\": []")
		fmt.Println("     }")
	} else {
		// Create backup
		backupPath := settingsPath + ".bak"
		if err := os.WriteFile(backupPath, data, 0644); err != nil {
			fmt.Printf("⚠️  Cannot create backup: %v\n", err)
			return
		}

		// Find the last closing brace
		lastBrace := strings.LastIndex(settingsStr, "}")
		if lastBrace == -1 {
			fmt.Println("⚠️  Invalid VS Code settings format")
			return
		}

		// Insert the new configuration
		newConfig := fmt.Sprintf(`  "github.copilot.chat.mcpServers": {
    "cloud-mcp": {
      "command": "%s",
      "args": []
    }
  }`, wrapperPath)

		// Check if we need a comma before our new config
		trimmed := strings.TrimSpace(settingsStr[:lastBrace])
		needsComma := len(trimmed) > 0 && trimmed[len(trimmed)-1] != '{'
		
		if needsComma {
			newConfig = ",\n" + newConfig
		}

		// Build the new settings
		newSettings := settingsStr[:lastBrace] + newConfig + "\n" + settingsStr[lastBrace:]

		// Write the new settings
		if err := os.WriteFile(settingsPath, []byte(newSettings), 0644); err != nil {
			fmt.Printf("⚠️  Cannot write VS Code settings: %v\n", err)
			// Restore backup
			os.Rename(backupPath, settingsPath)
			return
		}

		fmt.Println("✓ CloudMCP added to VS Code settings")
	}
}

func doUninstall() {
	fmt.Println("CloudMCP Uninstall")
	fmt.Println("==================")
	fmt.Println()

	homeDir, _ := os.UserHomeDir()
	
	// Remove from Claude Code
	if _, err := exec.LookPath("claude"); err == nil {
		fmt.Println("Removing from Claude Code...")
		cmd := exec.Command("claude", "mcp", "remove", "-s", "user", "cloud-mcp")
		if output, err := cmd.CombinedOutput(); err != nil {
			fmt.Printf("⚠️  Failed to remove from Claude Code: %v\n", err)
			if len(output) > 0 {
				fmt.Printf("   Output: %s\n", string(output))
			}
		} else {
			fmt.Println("✓ Removed from Claude Code")
		}
	}

	// Remove from Claude Desktop
	if runtime.GOOS == "darwin" {
		configPath := filepath.Join(homeDir, "Library", "Application Support", "Claude", "claude_desktop_config.json")
		if data, err := os.ReadFile(configPath); err == nil {
			var config map[string]interface{}
			if err := json.Unmarshal(data, &config); err == nil {
				if servers, ok := config["mcpServers"].(map[string]interface{}); ok {
					delete(servers, "cloud-mcp")
					if newData, err := json.MarshalIndent(config, "", "  "); err == nil {
						if err := os.WriteFile(configPath, newData, 0644); err == nil {
							fmt.Println("✓ Removed from Claude Desktop")
						}
					}
				}
			}
		}
	}

	// Remove from VS Code
	fmt.Println()
	fmt.Println("Removing from VS Code...")
	settingsPaths := []string{
		filepath.Join(homeDir, ".config", "Code", "User", "settings.json"),
		filepath.Join(homeDir, "Library", "Application Support", "Code", "User", "settings.json"),
		filepath.Join(homeDir, "AppData", "Roaming", "Code", "User", "settings.json"),
	}
	
	for _, settingsPath := range settingsPaths {
		if data, err := os.ReadFile(settingsPath); err == nil {
			if strings.Contains(string(data), "cloud-mcp") {
				fmt.Printf("⚠️  Please manually remove cloud-mcp from VS Code settings: %s\n", settingsPath)
				break
			}
		}
	}

	// Optionally remove ~/.cloud-mcp directory
	cloudMCPDir := filepath.Join(homeDir, ".cloud-mcp")
	fmt.Println()
	fmt.Printf("The configuration directory %s still exists.\n", cloudMCPDir)
	fmt.Println("You can manually remove it if you no longer need it.")
}