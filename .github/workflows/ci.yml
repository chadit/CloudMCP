name: CloudMCP CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:
    inputs:
      run_integration_tests:
        description: 'Run integration tests'
        required: false
        default: 'true'
        type: boolean

env:
  GO_VERSION: '1.24'
  GOLANGCI_LINT_VERSION: 'v1.54'

jobs:
  # Security Token Validation - First priority
  token-security:
    name: ğŸ”’ Token Security Validation
    runs-on: ubuntu-latest
    steps:
      - name: ğŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ğŸ” Validate Token Security
        env:
          # Optional tokens for validation (CI will validate format if present)
          LINODE_TOKEN: ${{ secrets.LINODE_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TEST_TOKEN: ${{ secrets.TEST_TOKEN }}
        run: |
          echo "ğŸ”’ Starting token security validation..."
          
          # Run token validation in CI mode (strict)
          ./scripts/validate-test-tokens.sh ci
          
          echo "âœ… Token security validation completed"

      - name: ğŸ“Š Upload Security Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: token-security-report
          path: |
            tmp/token-security-report.txt
            tmp/token-validation.log
          retention-days: 30

  # Code Quality and Testing
  test:
    name: ğŸ§ª Test Suite
    runs-on: ubuntu-latest
    needs: token-security  # Ensure token security passes first
    strategy:
      matrix:
        go-version: ['1.23', '1.24']
    
    steps:
      - name: ğŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup Go ${{ matrix.go-version }}
        uses: actions/setup-go@v4
        with:
          go-version: ${{ matrix.go-version }}

      - name: ğŸ“¦ Cache Go Modules
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ matrix.go-version }}-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-${{ matrix.go-version }}-

      - name: ğŸ“¥ Download Dependencies
        run: go mod download

      - name: ğŸ” Verify Dependencies
        run: go mod verify

      - name: ğŸ—ï¸ Build Application
        run: |
          go build -v -o bin/cloud-mcp ./cmd/server/
          chmod +x bin/cloud-mcp

      - name: ğŸ§ª Run Unit Tests
        run: |
          go test -v -race -coverprofile=coverage.out ./...

      - name: ğŸ“Š Test Coverage Report
        run: |
          go tool cover -html=coverage.out -o coverage.html
          go tool cover -func=coverage.out

      - name: ğŸ”’ Run Security-Specific Tests
        run: |
          echo "ğŸ”’ Running security token validation tests..."
          go test -v -race ./internal/testing/security/...

      - name: ğŸ“Š Upload Coverage Reports
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report-go${{ matrix.go-version }}
          path: |
            coverage.out
            coverage.html
          retention-days: 30

  # Code Quality Analysis
  lint:
    name: ğŸ” Code Quality
    runs-on: ubuntu-latest
    needs: token-security
    
    steps:
      - name: ğŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: ğŸ” Run golangci-lint
        uses: golangci/golangci-lint-action@v3
        with:
          version: ${{ env.GOLANGCI_LINT_VERSION }}
          args: --enable-all --disable forbidigo,exhaustruct,depguard,gci,lll,cyclop,funlen,tenv --timeout=10m

      - name: ğŸ”§ Check Formatting
        run: |
          if [ "$(gofumpt -l . | wc -l)" -gt 0 ]; then
            echo "âŒ Code is not properly formatted. Run 'gofumpt -w .'"
            gofumpt -l .
            exit 1
          fi
          echo "âœ… Code formatting is correct"

      - name: ğŸ”’ Security Scan with gosec
        run: |
          go install github.com/securecodewarrior/gosec/v2/cmd/gosec@latest
          gosec -fmt json -out gosec-report.json -stdout ./...

      - name: ğŸ“Š Upload Security Scan Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: security-scan-results
          path: gosec-report.json
          retention-days: 30

  # Integration Tests with Token Security
  integration:
    name: ğŸ”— Integration Tests
    runs-on: ubuntu-latest
    needs: [token-security, test]
    if: github.event.inputs.run_integration_tests == 'true' || github.event_name != 'workflow_dispatch'
    
    steps:
      - name: ğŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: ğŸ—ï¸ Build Application
        run: |
          go build -v -o bin/cloud-mcp ./cmd/server/
          chmod +x bin/cloud-mcp

      - name: ğŸ”’ Pre-Integration Token Validation
        env:
          LINODE_TOKEN: ${{ secrets.LINODE_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TEST_TOKEN: ${{ secrets.TEST_TOKEN }}
        run: |
          echo "ğŸ”’ Validating tokens before integration tests..."
          ./scripts/validate-test-tokens.sh validate

      - name: ğŸ§ª Run MCP Protocol Tests
        run: |
          echo "ğŸ§ª Running MCP protocol compliance tests..."
          go test -v -race ./internal/testing/mcp/...

      - name: ğŸ”— Run Integration Tests
        env:
          # Secure token handling in integration tests
          LINODE_TOKEN: ${{ secrets.LINODE_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TEST_TOKEN: ${{ secrets.TEST_TOKEN }}
        run: |
          echo "ğŸ”— Running integration tests with secure token handling..."
          
          # Create test environment file with secure permissions
          touch .env
          chmod 600 .env
          
          # Add minimal test configuration (tokens handled securely)
          cat > .env << EOF
          CLOUD_MCP_SERVER_NAME="CloudMCP-CI-Test"
          LOG_LEVEL=error
          ENABLE_METRICS=false
          EOF
          
          # Run integration tests
          cd test && ./test-local.sh

      - name: ğŸ”’ Post-Integration Security Audit
        if: always()
        run: |
          echo "ğŸ”’ Running post-integration security audit..."
          ./scripts/validate-test-tokens.sh audit

      - name: ğŸ“Š Upload Integration Test Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: integration-test-results
          path: |
            tmp/token-security-report.txt
            tmp/token-validation.log
            test/*.log
          retention-days: 30

  # Security Audit Job
  security-audit:
    name: ğŸ›¡ï¸ Security Audit
    runs-on: ubuntu-latest
    needs: [test, lint]
    
    steps:
      - name: ğŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: ğŸ”’ Comprehensive Security Audit
        env:
          LINODE_TOKEN: ${{ secrets.LINODE_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TEST_TOKEN: ${{ secrets.TEST_TOKEN }}
        run: |
          echo "ğŸ›¡ï¸ Running comprehensive security audit..."
          
          # Run full security audit
          ./scripts/validate-test-tokens.sh audit
          
          # Check file permissions
          ./scripts/check-file-permissions.sh

      - name: ğŸ” Dependency Security Scan
        run: |
          echo "ğŸ” Scanning dependencies for vulnerabilities..."
          go install github.com/sonatypecommunity/nancy@latest
          go list -json -deps ./... | nancy sleuth

      - name: ğŸ“Š Upload Security Audit Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: security-audit-results
          path: |
            tmp/token-security-report.txt
            tmp/token-validation.log
          retention-days: 90  # Keep security reports longer

  # Container Build Validation - Comprehensive Testing
  container-validation:
    name: ğŸ³ Container Build & Validation
    runs-on: ubuntu-latest
    needs: [test, lint]
    strategy:
      matrix:
        platform: [linux/amd64, linux/arm64]
        include:
          - platform: linux/amd64
            arch: amd64
          - platform: linux/arm64
            arch: arm64
    
    steps:
      - name: ğŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ğŸ”§ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          platforms: linux/amd64,linux/arm64

      - name: ğŸ”§ Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: ğŸ” Dockerfile Lint with hadolint
        run: |
          # Install hadolint
          wget -O hadolint https://github.com/hadolint/hadolint/releases/latest/download/hadolint-Linux-x86_64
          chmod +x hadolint
          
          # Lint Dockerfile
          ./hadolint Dockerfile
          
          # Also lint test Dockerfile
          ./hadolint Dockerfile.test

      - name: ğŸ—ï¸ Build Multi-Architecture Docker Image
        env:
          VERSION: ${{ github.sha }}
          PLATFORM: ${{ matrix.platform }}
        run: |
          echo "ğŸ—ï¸ Building Docker image for ${{ matrix.platform }}"
          
          # Build for specific platform
          docker buildx build \
            --platform ${{ matrix.platform }} \
            --build-arg VERSION=${VERSION} \
            --tag cloudmcp:ci-${{ matrix.arch }} \
            --load \
            .
          
          echo "âœ… Build completed for ${{ matrix.platform }}"

      - name: ğŸ”’ Container Security Scan with Trivy
        if: matrix.arch == 'amd64'  # Run security scan only on amd64 for performance
        run: |
          # Install Trivy for container security scanning
          curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sudo sh -s -- -b /usr/local/bin v0.45.0
          
          echo "ğŸ”’ Running comprehensive security scan..."
          
          # Detailed vulnerability scan
          trivy image \
            --exit-code 0 \
            --no-progress \
            --format table \
            --severity HIGH,CRITICAL \
            cloudmcp:ci-${{ matrix.arch }}
          
          # Generate JSON report for artifacts
          trivy image \
            --exit-code 0 \
            --no-progress \
            --format json \
            --output trivy-report-${{ matrix.arch }}.json \
            cloudmcp:ci-${{ matrix.arch }}
          
          echo "âœ… Security scan completed"

      - name: ğŸ§ª Container Functionality Testing
        if: matrix.arch == 'amd64'  # Run functional tests only on amd64 for performance
        run: |
          echo "ğŸ§ª Running comprehensive container functionality tests..."
          
          # Make test script executable
          chmod +x scripts/docker-test.sh
          
          # Run comprehensive container tests
          ./scripts/docker-test.sh \
            --name cloudmcp \
            --tag ci-${{ matrix.arch }} \
            --port 8080 \
            --multi-arch \
            --skip-security
          
          echo "âœ… Container functionality tests completed"

      - name: ğŸ¥ Container Health Check Validation
        if: matrix.arch == 'amd64'
        run: |
          echo "ğŸ¥ Testing container health check functionality..."
          
          # Start container with health check
          docker run -d \
            --name cloudmcp-health-test \
            -p 8081:8080 \
            -e LOG_LEVEL=info \
            -e ENABLE_METRICS=true \
            cloudmcp:ci-${{ matrix.arch }}
          
          # Wait for health check to pass
          echo "â³ Waiting for container to become healthy..."
          timeout=60
          counter=0
          
          while [ $counter -lt $timeout ]; do
            health_status=$(docker inspect cloudmcp-health-test --format='{{.State.Health.Status}}' 2>/dev/null || echo "starting")
            echo "Health status: $health_status (${counter}s)"
            
            if [ "$health_status" = "healthy" ]; then
              echo "âœ… Container is healthy!"
              break
            elif [ "$health_status" = "unhealthy" ]; then
              echo "âŒ Container health check failed!"
              docker logs cloudmcp-health-test
              exit 1
            fi
            
            sleep 2
            counter=$((counter + 2))
          done
          
          if [ $counter -ge $timeout ]; then
            echo "âŒ Container health check timeout!"
            docker logs cloudmcp-health-test
            exit 1
          fi
          
          # Test health endpoint directly
          health_response=$(curl -f -s http://localhost:8081/health || echo "failed")
          if [ "$health_response" != "failed" ]; then
            echo "âœ… Health endpoint test passed"
            echo "Response: $health_response"
          else
            echo "âŒ Health endpoint test failed"
            exit 1
          fi
          
          # Cleanup
          docker stop cloudmcp-health-test
          docker rm cloudmcp-health-test

      - name: ğŸ“Š Container Performance Metrics
        if: matrix.arch == 'amd64'
        run: |
          echo "ğŸ“Š Collecting container performance metrics..."
          
          # Start container for performance testing
          docker run -d \
            --name cloudmcp-perf-test \
            -p 8082:8080 \
            -e LOG_LEVEL=error \
            -e ENABLE_METRICS=true \
            --memory=128m \
            --cpus=0.5 \
            cloudmcp:ci-${{ matrix.arch }}
          
          # Wait for startup
          sleep 10
          
          # Collect metrics
          echo "ğŸ“ˆ Container performance metrics:"
          
          # Memory usage
          memory_usage=$(docker stats cloudmcp-perf-test --no-stream --format "{{.MemUsage}}" 2>/dev/null)
          echo "Memory usage: $memory_usage"
          
          # CPU usage
          cpu_usage=$(docker stats cloudmcp-perf-test --no-stream --format "{{.CPUPerc}}" 2>/dev/null)
          echo "CPU usage: $cpu_usage"
          
          # Image size
          image_size=$(docker images cloudmcp:ci-${{ matrix.arch }} --format "{{.Size}}")
          echo "Image size: $image_size"
          
          # Response time test
          response_time=$(curl -w "%{time_total}" -s -o /dev/null http://localhost:8082/health || echo "failed")
          if [ "$response_time" != "failed" ]; then
            echo "Health endpoint response time: ${response_time}s"
          fi
          
          # Cleanup
          docker stop cloudmcp-perf-test
          docker rm cloudmcp-perf-test
          
          echo "âœ… Performance metrics collection completed"

      - name: ğŸ”§ Container Framework Tests
        if: matrix.arch == 'amd64'
        run: |
          echo "ğŸ”§ Running container testing framework validation..."
          
          # Set environment for container tests
          export CONTAINER_TEST_MODE=true
          export CONTAINER_IMAGE=cloudmcp:ci-${{ matrix.arch }}
          export CONTAINER_PORT=8083
          
          # Run container framework tests
          go test -v -timeout=10m ./internal/testing/container/... \
            -args -test.container-image=cloudmcp:ci-${{ matrix.arch }}
          
          echo "âœ… Container framework tests completed"

      - name: ğŸ¯ MCP Protocol Validation in Container
        if: matrix.arch == 'amd64'
        run: |
          echo "ğŸ¯ Validating MCP protocol compliance in container..."
          
          # Start container for MCP testing
          docker run -d \
            --name cloudmcp-mcp-test \
            -p 8084:8080 \
            -e LOG_LEVEL=debug \
            -e ENABLE_METRICS=true \
            cloudmcp:ci-${{ matrix.arch }}
          
          # Wait for startup
          sleep 5
          
          # Test MCP protocol endpoints (placeholder - would integrate with actual MCP testing)
          echo "ğŸ” Testing MCP protocol compliance..."
          
          # Basic connectivity test
          if curl -f -s http://localhost:8084/health >/dev/null; then
            echo "âœ… Container MCP service is accessible"
          else
            echo "âŒ Container MCP service is not accessible"
            docker logs cloudmcp-mcp-test
            exit 1
          fi
          
          # Run MCP protocol compliance tests
          go test -v ./internal/testing/mcp/... \
            -args -test.server-url=http://localhost:8084
          
          # Cleanup
          docker stop cloudmcp-mcp-test
          docker rm cloudmcp-mcp-test
          
          echo "âœ… MCP protocol validation completed"

      - name: ğŸ“Š Upload Security Scan Results
        if: matrix.arch == 'amd64' && always()
        uses: actions/upload-artifact@v4
        with:
          name: security-scan-results-${{ matrix.arch }}
          path: |
            trivy-report-${{ matrix.arch }}.json
          retention-days: 30

      - name: ğŸ“Š Upload Container Test Results
        if: matrix.arch == 'amd64' && always()
        uses: actions/upload-artifact@v4
        with:
          name: container-test-results-${{ matrix.arch }}
          path: |
            test-results/
            performance-results/
          retention-days: 30

  # Multi-Architecture Image Manifest
  container-manifest:
    name: ğŸ³ Multi-Arch Container Manifest
    runs-on: ubuntu-latest
    needs: [container-validation]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - name: ğŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ğŸ”§ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ğŸ—ï¸ Create Multi-Architecture Manifest
        env:
          VERSION: ${{ github.sha }}
        run: |
          echo "ğŸ—ï¸ Creating multi-architecture manifest..."
          
          # Build and push multi-arch image (simulation - would require registry in real scenario)
          docker buildx build \
            --platform linux/amd64,linux/arm64 \
            --build-arg VERSION=${VERSION} \
            --tag cloudmcp:latest-multiarch \
            --load=false \
            .
          
          echo "âœ… Multi-architecture manifest created"

# Security Notice
# This CI pipeline implements comprehensive token security validation:
# 1. Token format validation without exposure
# 2. Secure token handling in all steps
# 3. Automatic token redaction in logs
# 4. Security audit reporting
# 5. Constant-time validation to prevent timing attacks